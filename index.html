<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Nebula Pong</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Orbitron", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at center, #0b0f1f 0%, #040612 55%, #010108 100%);
        color: #eef1ff;
        height: 100vh;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      canvas {
        width: min(90vw, 1200px);
        aspect-ratio: 16 / 9;
        border: 3px solid rgba(148, 0, 255, 0.35);
        border-radius: 18px;
        box-shadow: 0 0 45px rgba(98, 0, 255, 0.4), 0 0 120px rgba(0, 255, 255, 0.1);
        background: radial-gradient(circle at center, rgba(28, 0, 40, 0.95) 0%, rgba(7, 0, 24, 0.92) 40%, rgba(2, 0, 11, 0.85) 100%);
      }

      .hud {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 1200px);
        pointer-events: none;
        display: flex;
        justify-content: space-between;
        font-size: clamp(1rem, 2.3vw, 2.3rem);
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.7), 0 0 20px rgba(98, 0, 255, 0.7);
        letter-spacing: 0.3em;
      }

      .hud span {
        flex: 1;
        text-align: center;
      }

      .hud span:first-child {
        text-align: left;
      }

      .hud span:last-child {
        text-align: right;
      }

      .instructions {
        position: absolute;
        bottom: clamp(12px, 3vh, 32px);
        left: 50%;
        transform: translateX(-50%);
        font-size: clamp(0.8rem, 1.8vw, 1.2rem);
        color: rgba(224, 238, 255, 0.75);
        text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        letter-spacing: 0.2em;
      }

      .signature {
        position: absolute;
        top: clamp(10px, 5vh, 40px);
        right: clamp(12px, 5vw, 70px);
        font-size: clamp(0.6rem, 1.4vw, 1rem);
        opacity: 0.7;
        letter-spacing: 0.2em;
        text-transform: uppercase;
      }

      .pause-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(3px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .pause-overlay.active {
        display: flex;
      }

      .pause-content {
        text-align: center;
        color: #eef1ff;
      }

      .pause-button {
        font-size: clamp(2rem, 4vw, 4rem);
        font-family: "Orbitron", monospace;
        color: rgba(0, 255, 255, 0.9);
        text-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(98, 0, 255, 0.6);
        letter-spacing: 0.2em;
        margin-bottom: 1rem;
        text-transform: uppercase;
      }

      .pause-instruction {
        font-size: clamp(1rem, 2vw, 1.5rem);
        color: rgba(224, 238, 255, 0.8);
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        letter-spacing: 0.1em;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="1280" height="720"></canvas>
    <div class="hud">
      <span id="leftScore">00</span>
      <span>NEON NEBULA</span>
      <span id="rightScore">00</span>
    </div>
    <div class="instructions">Move your paddle with the mouse • Press SPACE to pause</div>
    <div class="signature">COSMIC PONG EDITION</div>
    
    <div class="pause-overlay" id="pauseOverlay">
      <div class="pause-content">
        <div class="pause-button">⏸ PAUSED</div>
        <div class="pause-instruction">Press SPACE to resume</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const leftScoreEl = document.getElementById("leftScore");
      const rightScoreEl = document.getElementById("rightScore");
      const pauseOverlay = document.getElementById("pauseOverlay");

      const config = {
        paddleHeight: 160,
        paddleWidth: 16,
        paddleGlow: "rgba(0, 255, 255, 0.65)",
        ballRadius: 14,
        ballGlow: "rgba(255, 0, 170, 0.65)",
        maxBallSpeed: 10,
        baseBallSpeed: 4,
        particleCount: 80,
        aiLag: 0.22,
      };

      const state = {
        player: { x: 40, y: canvas.height / 2 - config.paddleHeight / 2, vy: 0 },
        ai: { x: canvas.width - 40 - config.paddleWidth, y: canvas.height / 2 - config.paddleHeight / 2, vy: 0 },
        ball: { x: canvas.width / 2, y: canvas.height / 2, vx: config.baseBallSpeed, vy: config.baseBallSpeed * 0.3 },
        scores: { left: 0, right: 0 },
        particles: [],
        time: 0,
        paused: false,
        aiFatigue: 0,
        rallyStartTime: 0,
        windTunnel: { active: false, startTime: 0, direction: 1, strength: 0, x: 0 },
        lastWindTunnelTime: 0,
      };

      function resetBall(direction = 1) {
        state.ball.x = canvas.width / 2;
        state.ball.y = canvas.height / 2;
        const angle = (Math.random() * Math.PI) / 3 - Math.PI / 6;
        const speed = config.baseBallSpeed + Math.random() * 2;
        state.ball.vx = Math.cos(angle) * speed * direction;
        state.ball.vy = Math.sin(angle) * speed;
        // Reset AI fatigue at the start of each rally
        state.aiFatigue = 0;
        state.rallyStartTime = state.time;
      }

      function updateScores() {
        leftScoreEl.textContent = state.scores.left.toString().padStart(2, "0");
        rightScoreEl.textContent = state.scores.right.toString().padStart(2, "0");
      }

      function togglePause() {
        state.paused = !state.paused;
        if (state.paused) {
          pauseOverlay.classList.add('active');
        } else {
          pauseOverlay.classList.remove('active');
        }
      }

      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      function addParticles(x, y, color) {
        for (let i = 0; i < 6; i++) {
          state.particles.push({
            x,
            y,
            life: 1,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            color,
          });
        }
        if (state.particles.length > config.particleCount) {
          state.particles.splice(0, state.particles.length - config.particleCount);
        }
      }


      let pointerY = state.player.y + config.paddleHeight / 2;
      canvas.addEventListener("pointermove", (event) => {
        const rect = canvas.getBoundingClientRect();
        const y = event.clientY - rect.top;
        pointerY = clamp(y - config.paddleHeight / 2, 20, canvas.height - config.paddleHeight - 20);
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === ' ') {
          event.preventDefault();
          togglePause();
        }
      });

      function update(delta) {
        state.time += delta;

        // Smoothly move towards pointer control with speed cap
        const playerTargetDistance = pointerY - state.player.y;
        const playerMoveDistance = Math.sign(playerTargetDistance) * Math.min(Math.abs(playerTargetDistance) * 0.18, 800 * delta);
        state.player.y += playerMoveDistance;

        const ball = state.ball;
        
        // Gradually increase ball speed over time during rallies
        const ballRallyTime = state.time - state.rallyStartTime;
        const speedIncrease = Math.min(1.5, ballRallyTime * 0.1); // Max 50% speed increase
        const currentMaxSpeed = config.maxBallSpeed + speedIncrease;
        const currentBaseSpeed = config.baseBallSpeed + speedIncrease * 0.5;
        
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall collision
        if (ball.y < config.ballRadius + 10 || ball.y > canvas.height - config.ballRadius - 10) {
          ball.vy *= -1;
          addParticles(ball.x, clamp(ball.y, config.ballRadius + 10, canvas.height - config.ballRadius - 10), "rgba(0, 255, 200, 0.6)");
        }

        // Player paddle collision
        if (
          ball.x - config.ballRadius < state.player.x + config.paddleWidth &&
          ball.x - config.ballRadius > state.player.x &&
          ball.y > state.player.y &&
          ball.y < state.player.y + config.paddleHeight
        ) {
          const relative = (ball.y - (state.player.y + config.paddleHeight / 2)) / (config.paddleHeight / 2);
          ball.vx = Math.abs(ball.vx) * 1.05;
          ball.vx = clamp(ball.vx, currentBaseSpeed, currentMaxSpeed);
          ball.vy = relative * currentMaxSpeed * 0.7;
          addParticles(ball.x, ball.y, "rgba(255, 0, 170, 0.75)");
        }

        // AI paddle movement with fatigue system
        const rallyTime = state.time - state.rallyStartTime;
        // Accumulate fatigue over time during the rally (slower decay)
        state.aiFatigue = Math.min(1, rallyTime * 0.08);
        
        // Calculate speed based on fatigue - starts fast, gets slower
        const baseSpeed = 800 * delta; // Higher base speed
        const speedDecay = state.aiFatigue * 0.7; // Up to 70% speed reduction
        const maxSpeed = baseSpeed * (1 - speedDecay);
        
        // Add some intentional delay based on fatigue
        const fatigueDelay = state.aiFatigue * 0.5;
        const adjustedLag = config.aiLag + fatigueDelay;
        
        const targetY = ball.y - config.paddleHeight / 2 + Math.sin(state.time * 1.7) * 35;
        const targetDistance = targetY - state.ai.y;
        const moveDistance = Math.sign(targetDistance) * Math.min(Math.abs(targetDistance) * adjustedLag, maxSpeed);
        state.ai.y += moveDistance;
        state.ai.y = clamp(state.ai.y, 20, canvas.height - config.paddleHeight - 20);

        // Wind tunnel system
        
        // Check if we should spawn a new wind tunnel
        const timeSinceLastWind = state.time - state.lastWindTunnelTime;
        const windSpawnChance = Math.min(0.3, rallyTime * 0.02); // Increases with rally time
        
        if (!state.windTunnel.active && timeSinceLastWind > 3 && Math.random() < windSpawnChance) {
          state.windTunnel.active = true;
          state.windTunnel.startTime = state.time;
          state.windTunnel.direction = Math.random() < 0.5 ? 1 : -1;
          state.windTunnel.strength = 0.2 + Math.random() * 0.5;
          state.windTunnel.x = canvas.width * 0.33 + Math.random() * (canvas.width * 0.34); // 1/3 to 2/3 of board
          state.lastWindTunnelTime = state.time;
        }
        
        // Check if wind tunnel should end (5 seconds duration)
        if (state.windTunnel.active && state.time - state.windTunnel.startTime > 5) {
          state.windTunnel.active = false;
        }
        
        // Apply wind tunnel effect to ball when in wind tunnel area
        if (state.windTunnel.active && ball.x > state.windTunnel.x - 60 && ball.x < state.windTunnel.x + 60) {
          const windForce = state.windTunnel.strength * state.windTunnel.direction * delta * 40;
          ball.vy += windForce;
        }

        // AI paddle collision
        if (
          ball.x + config.ballRadius > state.ai.x &&
          ball.x + config.ballRadius < state.ai.x + config.paddleWidth &&
          ball.y > state.ai.y &&
          ball.y < state.ai.y + config.paddleHeight
        ) {
          const relative = (ball.y - (state.ai.y + config.paddleHeight / 2)) / (config.paddleHeight / 2);
          ball.vx = -Math.abs(ball.vx) * 1.05;
          ball.vx = clamp(ball.vx, -currentMaxSpeed, -currentBaseSpeed);
          ball.vy = relative * currentMaxSpeed * 0.75;
          addParticles(ball.x, ball.y, "rgba(0, 220, 255, 0.75)");
        }

        // Scoring
        if (ball.x < -config.ballRadius) {
          state.scores.right += 1;
          updateScores();
          resetBall(1);
        } else if (ball.x > canvas.width + config.ballRadius) {
          state.scores.left += 1;
          updateScores();
          resetBall(-1);
        }

        // Update particles
        state.particles = state.particles
          .map((particle) => ({
            ...particle,
            life: particle.life - delta * 2,
            x: particle.x + particle.vx,
            y: particle.y + particle.vy,
            vx: particle.vx * 0.96,
            vy: particle.vy * 0.96,
          }))
          .filter((particle) => particle.life > 0);
      }

      function drawBackground(time) {
        const gradient = ctx.createRadialGradient(
          canvas.width / 2 + Math.sin(time * 0.2) * 180,
          canvas.height / 2 + Math.cos(time * 0.25) * 180,
          40,
          canvas.width / 2,
          canvas.height / 2,
          canvas.width * 0.75
        );
        gradient.addColorStop(0, "rgba(255, 0, 255, 0.12)");
        gradient.addColorStop(0.3, "rgba(0, 255, 255, 0.07)");
        gradient.addColorStop(0.6, "rgba(13, 0, 40, 0.35)");
        gradient.addColorStop(1, "rgba(3, 0, 14, 0.9)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw plasma waves
        const waveCount = 3;
        for (let i = 0; i < waveCount; i++) {
          const hue = (time * 30 + i * 120) % 360;
          ctx.strokeStyle = `hsla(${hue}, 90%, 60%, 0.12)`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let x = 0; x < canvas.width; x += 12) {
            const y =
              canvas.height / 2 +
              Math.sin(time * 0.9 + x * 0.018 + i) * 70 +
              Math.cos(time * 0.5 + x * 0.02 + i) * 30;
            ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
      }

      function drawPaddle(paddle, glowColor) {
        ctx.save();
        const gradient = ctx.createLinearGradient(0, paddle.y, 0, paddle.y + config.paddleHeight);
        gradient.addColorStop(0, "rgba(0, 255, 255, 0.9)");
        gradient.addColorStop(0.5, "rgba(255, 0, 255, 0.9)");
        gradient.addColorStop(1, "rgba(255, 255, 255, 0.9)");
        ctx.shadowBlur = 30;
        ctx.shadowColor = glowColor;
        ctx.fillStyle = gradient;
        ctx.fillRect(paddle.x, paddle.y, config.paddleWidth, config.paddleHeight);
        ctx.restore();
      }

      function drawBall(ball) {
        ctx.save();
        const gradient = ctx.createRadialGradient(ball.x, ball.y, 2, ball.x, ball.y, config.ballRadius * 1.4);
        gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(0.4, "rgba(255, 80, 200, 0.9)");
        gradient.addColorStop(1, "rgba(80, 255, 255, 0)");
        ctx.shadowBlur = 25;
        ctx.shadowColor = config.ballGlow;
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, config.ballRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawParticles() {
        for (const particle of state.particles) {
          ctx.save();
          ctx.globalAlpha = particle.life;
          ctx.fillStyle = particle.color;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, 6 * particle.life, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      function drawWindTunnel() {
        if (!state.windTunnel.active) return;
        
        ctx.save();
        
        // Create wind tunnel visual effect
        const tunnelX = state.windTunnel.x;
        const tunnelWidth = 120;
        const tunnelHeight = canvas.height;
        const windAge = state.time - state.windTunnel.startTime;
        const alpha = Math.sin(windAge * 3) * 0.3 + 0.4; // Pulsing effect
        
        // Draw wind tunnel area
        const gradient = ctx.createLinearGradient(tunnelX - tunnelWidth/2, 0, tunnelX + tunnelWidth/2, 0);
        if (state.windTunnel.direction > 0) {
          gradient.addColorStop(0, `rgba(0, 255, 255, ${alpha * 0.2})`);
          gradient.addColorStop(1, `rgba(0, 255, 255, ${alpha * 0.6})`);
        } else {
          gradient.addColorStop(0, `rgba(255, 100, 255, ${alpha * 0.6})`);
          gradient.addColorStop(1, `rgba(255, 100, 255, ${alpha * 0.2})`);
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(tunnelX - tunnelWidth/2, 0, tunnelWidth, tunnelHeight);
        
        // Draw wind particles
        for (let i = 0; i < 15; i++) {
          const y = (state.time * 100 + i * 40) % tunnelHeight;
          const x = tunnelX + (Math.sin(state.time * 2 + i) * 30);
          const particleAlpha = Math.sin(state.time * 4 + i) * 0.5 + 0.5;
          
          ctx.fillStyle = state.windTunnel.direction > 0 
            ? `rgba(0, 255, 255, ${particleAlpha * alpha})` 
            : `rgba(255, 100, 255, ${particleAlpha * alpha})`;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }

      let lastTime = performance.now();
      function loop(timestamp) {
        const delta = Math.min((timestamp - lastTime) / 1000, 0.033);
        lastTime = timestamp;

        // Only update game logic if not paused
        if (!state.paused) {
          update(delta);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground(state.time);
        drawWindTunnel();
        drawParticles();
        drawPaddle(state.player, config.paddleGlow);
        drawPaddle(state.ai, "rgba(255, 0, 255, 0.7)");
        drawBall(state.ball);

        // Midline with glow
        ctx.save();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
        ctx.lineWidth = 4;
        ctx.setLineDash([20, 25]);
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 20);
        ctx.lineTo(canvas.width / 2, canvas.height - 20);
        ctx.stroke();
        ctx.restore();

        requestAnimationFrame(loop);
      }

      updateScores();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
